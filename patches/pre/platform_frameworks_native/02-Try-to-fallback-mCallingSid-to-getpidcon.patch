From cb97ba7d6729be7ed0c85d4709cf590b43239671 Mon Sep 17 00:00:00 2001
From: ChonDoit <thphantomblog@gmail.com>
Date: Wed, 5 Apr 2023 15:18:15 -0300
Subject: [PATCH] Try to fallback mCallingSid to getpidcon

This is needed because old vendors (before April 2019 ~) don't support
reporting SELinux context of the caller.
This doesn't work for all processes, because it requires some additional
SELinux permissions. At the moment, only keystore2 requires this

As a rule of thumb, assume only 3.18 kernel are old enough to have that
issue.
That's not strictly accurate, there have also been 4.4 kernels with that
issue (maybe even 4.9?). But let's assume that devices with >=4.4
kernels have got an upgrade after April 2019
---
 libs/binder/IPCThreadState.cpp | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/libs/binder/IPCThreadState.cpp b/libs/binder/IPCThreadState.cpp
index c415ea02e2..1ac950de60 100644
--- a/libs/binder/IPCThreadState.cpp
+++ b/libs/binder/IPCThreadState.cpp
@@ -36,6 +36,7 @@
 #include <sched.h>
 #include <signal.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <sys/ioctl.h>
 #include <sys/resource.h>
 #include <unistd.h>
@@ -1245,6 +1246,26 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
             mCallingSid = reinterpret_cast<const char*>(tr_secctx.secctx);
             mCallingUid = tr.sender_euid;
             mLastTransactionBinderFlags = tr.flags;
+
+            // This is recoding libselinux's getpidcon()
+            // We are in a NDK lib, so we need to keep changes to a minimum
+            bool allocatedSid = false;
+            if (mCallingSid == nullptr && mCallingPid != 0) {
+                char buf[4096];
+                char *path = NULL;
+                (void)asprintf(&path, "/proc/%d/attr/current", mCallingPid);
+                int fd = open(path, O_RDONLY | O_CLOEXEC);
+                if (fd != -1) {
+                    int readRet = read(fd, buf, sizeof(buf)-1);
+                    if (readRet != -1) {
+                        buf[readRet] = 0;
+                        mCallingSid = strdup(buf);
+                        allocatedSid = true;
+                    }
+                    close(fd);
+                }
+                free(path);
+            }
 
             // ALOGI(">>>> TRANSACT from pid %d sid %s uid %d\n", mCallingPid,
             //    (mCallingSid ? mCallingSid : "<N/A>"), mCallingUid);
@@ -1310,6 +1331,7 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
 
             mServingStackPointer = origServingStackPointer;
             mCallingPid = origPid;
+            if (allocatedSid) free((void*)mCallingSid);
             mCallingSid = origSid;
             mCallingUid = origUid;
             mStrictModePolicy = origStrictModePolicy;
-- 
2.40.0

